---
layout: post
title: "Asynchronous patterns in Node.js"
author: NodeKC
tags:
---

# Asynchronous patterns in Node.js

## A common problem and solution

First, let's see the problem we're trying to avoid:

Let's start by creating a few files in a brand new directory. Use the name of the files below and the contents as described for this example. The numeric names of the file are used to help clarify the point being made.

`1.html`
{% highlight html %}
<span class="Speaker">Joe Andaverde</span>
<p class="bio">Joe is a Software Engineer for Softek Solutions, Inc. He's passionate about sharing his knowledge with others.</p>
{% endhighlight %}

`2.html`
{% highlight html %}
<span class="Speaker">Dusty Burwell</span>
<p class="bio">Dusty is a dude.</p>
{% endhighlight %}

{% highlight javascript %}
var fs = require('fs');

for (var i = 1; i <= 2; i++) {
  fs.readFile(i + ".html", function (err, data) {
    if (err) return;

    var matches = data.toString().match(/<span class=\"Speaker\">([\s\S]+)<\/span>[\s\S]+<p class=\"bio\">([\s\S]+)<\/p>/i);
    
    if (matches) {
        var name = matches[1];
        var bio = matches[2];
        fs.writeFile(i + '.json', JSON.stringify({name: name, bio: bio}, null, 2));
    }
  });
}
{% endhighlight %}

Go back to your command window and list files in your current working directory. Notice that the only file created was `3.json`. This is because the callback from read file doesn't actually get executed until the loop has completed. Any other statements after the for loop would also be executed before the callback. This is, in part, because Node is single threaded. The event loop hasn't had a chance to invoke your callback. In any case, all of the callbacks are being fired and overwriting `3.json`.

How do we avoid this? The important concept here is how scope is handled in JavaScript. Unlike other languages that use block level scope, JavaScript's scope is at a function level. We can get around this problem by introducing a new scope in each iteration of the loop to capture the value of `i` at that moment:

{% highlight javascript %}
var fs = require('fs');

for (var i = 1; i <= 2; i++) {
  (function (i) { //Create a new scope that takes a single argument
      fs.readFile(i + ".html", function (err, data) {
        if (err) return;

        var matches = data.toString().match(/<span class=\"Speaker\">([\s\S]+)<\/span>[\s\S]+<p class=\"bio\">([\s\S]+)<\/p>/i);
        
        if (matches) {
            var name = matches[1];
            var bio = matches[2];
            fs.writeFile(i + '.json', JSON.stringify({name: name, bio: bio}, null, 2));
        }
      });
  })(i);//Execute this function with the current value of i
}
{% endhighlight %}

The lesson to be learned here is that new scopes are your best friend when performing asynchronous actions in JavaScript.

## Asynchronous calls in parallel and then joining them

More often than not there's a need to invoke a set of tasks asynchronously and then start a new set of tasks after completion. There are a variety of libraries that help with performing this situation and cleaning up the code a lot. 

{% highlight javascript %}
var fs = require('fs');
var bios = [];
var biosParsed = 0;
var biosToParse = ["1.html", "2.html"];


var saveBios = function (bios) {
  for (var i = 0; i < bios.length; i++) {
    fs.writeFile(bios[i].name + ".txt", JSON.stringify(bios[i]));  
  }
};

for (var i = 0; i < biosToParse.length; i++) {
  (function (fileName) {
    fs.readFile(fileName, function (err, data) {

      var matches = data.toString().match(/<span class=\"Speaker\">([\s\S]+)<\/span>[\s\S]+<p class=\"bio\">([\s\S]+)<\/p>/i);
      
      if (matches) {
        bios.push({
          name: matches[1],
          bio: matches[2]
        });
      }

      biosParsed++;
      
      //Have all pending callbacks been invoked?
      if (biosParsed == biosToParse.length) {
        //Save bios now that all async actions have completed
        saveBios(bios);
      }
    });
  })(biosToParse[i]);
}
{% endhighlight %}

In the example above, note that we keep track of how many times the `readFile` callback is invoked. Once the value matches the number of callbacks we're waiting on we can continue with saving off the biographies. This can get quite ugly the more complex your application becomes. A very good library for dealing with this is `async`. Here's an example of how async could be used to clean up the code above.

First, you should install the async module.

{% highlight bash %}
npm install async
{% endhighlight %}

{% highlight javascript %}
var fs = require('fs');
var async = require('async');
var biosToParse = ["1.html", "2.html"];

var saveBios = function (bios) {
  for (var i = 0; i < bios.length; i++) {
    fs.writeFile(bios[i].name + ".txt", JSON.stringify(bios[i]));  
  }
};

var parseOperations = [];

for (var i = 0; i < biosToParse.length; i++) {
  parseOperations.push((function (fileName) {
    return function (callback) {
      fs.readFile(fileName, function (err, data) {
        var matches = data.toString().match(/<span class=\"Speaker\">([\s\S]+)<\/span>[\s\S]+<p class=\"bio\">([\s\S]+)<\/p>/i);
        
        //The first argument by convention is the error
        //The second argument is aggregated with all other async results
        callback(null, {
          name: matches[1],
          bio: matches[2]
        });
      });
    };
  })(biosToParse[i]));
}

async.parallel(parseOperations, function (err, results) {
  saveBios(results)
});
{% endhighlight %}

Imagine the above where you had multiple things needing to happen in parallel. Remember how we kept around the `biosParsed` counter a few examples back? Keeping track of all the counters for more complicated examples could get extremely messy. Using `async` we're able to avoid these arbitrary counters and organize our code better. Another pattern to use is called `promises`.

## Promises

{% highlight javascript %}
var fs = require('fs');
var p = require("promise-extended"),
    Promise = p.Promise;

var files = ["0.html", "1.html"]; 

var operations = [];

for (var i = 0; i < files.length; i++)
{
   (function (fileName) {
      var p = new Promise();
      fs.readFile(fileName, function (err, data) {
         var matches = data.toString().match(/<span class=\"Speaker\">([\s\S]+)<\/span>[\s\S]+<p class=\"bio\">([\s\S]+)<\/p>/i);

         p.callback({
            name: matches[1],
            bio: matches[2]
         });
      });

      operations.push(p.promise());
   })(files[i]);
}

p.when(operations).then(function (bios) {
  for (var i = 0; i < bios.length; i++) {
     fs.writeFile(bios[i].name + ".txt", JSON.stringify(bios[i]));  
  }
});

{% endhighlight %}

### What are they?

Promises are an abstraction that sit on top of asynchronous actions giving a concrete value to work with that represents a future value.

{% highlight javascript %}
var Promise = require("promise-extended").Promise;

function asyncAction(){
    var p  = new Promise();
    process.nextTick(function(){
        p.callback(1);
    });
    return p.promise();
}

asyncAction().then(function(res){
    console.log(res); //1;
});

{% endhighlight %}

In the above example we have the `function` `asyncAction` which returns a promises that will resolve on the next event loop with `1`.

### Ok so what?

So where promises become a powerful in helping managing the callback madness is when managing multiple async actions in parallel or ensuring actions happen in a given order.

Example of managing execution order

{% highlight javascript %}

var Promise = require("promise-extended").Promise;

var asyncCount = (function(){
    var currentCount = 0;
    return function(){
        var p  = new Promise();
        process.nextTick(function(){
            p.callback(++currentCount);
        });
        return p.promise();
    }
}());

asyncCount()
    .then(function(currCount){
        console.log(currCount); //1

        //we return a promise from in here which will cause then to wait for this one to resolve.
        return asyncCount();
    })
    .then(function(currCount){
        console.log(currCount); //2

        //returning another promise!
        return asyncCount();
    })
    .then(function(count){
        //now we have the result from the last asyncCount call which is 3
        console.log(count); //3
    });

{% endhighlight %}

Example of managing multiple async actions at once.

{% highlight javascript %}
var p = require("promise-extended"),
    Promise = p.Promise;

var asyncWait = function(timeout){
    var ret = new Promise();
    setTimeout(function(){
        ret.callback(timeout);
    }, timeout);
    return ret.promise();
}


//use the when method to wait for all of the passed in promises to resolve.
p.when(
    asyncWait(1000),
    asyncWait(900),
    asyncWait(800),
    asyncWait(700),
    asyncWait(600),
    asyncWait(500),
).then(function(res){
    console.log(res); //[1000,900,800,700,600,500];
});

{% endhighlight %}

In the above example `when` returns a promise that waits for all the passed in promises to resolve.


###Error handling.

Error handling with promises is simplified greatly because you do not have to worry about errors unless your code cares about it directly.

{% highlight javascript %}
var asyncCount = (function(){
    var currentCount = 0;
    return function(){
        var p  = new Promise();
        process.nextTick(function(){
            p.callback(++currentCount);
        });
        return p.promise();
    }
}());

asyncCount()
    .then(function(count){
        console.log(count); //1
        return asyncCount();
    })
    .then(function(){
        throw new Error("Oops an error occurred"));
    })
    .then(function(){
       return asyncCount();
    })
    .then(function(res){/*wont be called*/}, function (err){
        console.log(err.message); //Oops an error occurred ...
    })
{% endhighlight %}






